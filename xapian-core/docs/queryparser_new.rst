============================
Xapian QueryParser
============================

.. contents:: Table of contents
   :depth: 2


Introduction
============

This document is intended to provide the details of ``Xapian::QueryParser``
- the syntax and the implementation details.

The Parser is generated by `Lemon Parser Generator`_. Lemon is an LALR parser
generator for C or C++. Rather than generating a complete and working program,
it generates only a few subroutines that implements the parser.

The `Xapian QueryParser`_ contains a self-written lexer( descried below, in
The Lexer) which tokenizes the query, and each time after figuring out
the type of token, calls the Lemon generated parser [to be specific, calls
the method `Parse`_ with the token detected and the corresponding information
of the token.


The Parser
===========

Functioning of Parser, The Parse Tree
++++++++++++++++++++++++++++++++++++++++

Following examples describe the functioning of the parser, the overall view
as to how are the tokens generated and how are they processed and parsed.

The bottom up parse tree corresponding to the QueryParser LR(1) grammar are
shown and described.

**Unless mentioned explicitly, the Query objects correspond to the default
stemming option ( STEM_SOME, and hence the 'Z' prefix in some/most of them )**

A Simple Query
---------------

Consider the following query::

	latest new watches

Here the tokens generated by the lexer are : TERM ("latest"), GROUP_TERM
("new") and GROUP_TERM ("watches").

The parser then reduces the tokens in a bottom-up manner as follow::



                      query		Level-7
                        |
                       expr		Level-6
                        |
                      prob_expr		Level-5
                        |
                       term		Level-4
                        |
                    compound_term	Level-3
                        |
                      group		Level-2
                      /   \
                     /     \
                  group     \		Level-1
                  /  \       \
                 /    \       \
                /      \       \
             TERM  GROUP_TERM  GROUP_TERM
               |        |       |
             "latest"  "new"  "watches"

The corresponding grammar rules applied in the order of application are
as follow::

	Level 1 - group ::= TERM GROUP_TERM.
	Level 2 - group ::= group GROUP_TERM.
	Level 3 - compound_term ::= group.
	Level 4 - term ::= compound_term.
	Level 5 - prob_expr ::= term.
	Level 6 - expr ::= prob_expr.
	Level 7 - query ::= expr.

In this case, the Query object formed is::

	Query((Zlatest@1 OR Znew@2 OR Zwatch@3))

Boolean Query
--------------

Consider the following query::

	xapian OR google

Here the tokens generated by the lexer are : TERM ("xapian"), OR and
TERM ("google")

The parser then reduces the tokens in a bottom-up manner as follow::

                      query		Level-6
                        |
                      expr		Level-5
                      / |  \
                     /  |   \
                    /   |    \
              bool_arg  |   bool_arg	Level-4
                 |      |      |
                expr    |     expr	Level-3
                 |      |      |
            prob_expr   |    prob_expr	Level-2
                 |      |      |
               term     |     term	Level-1
                 |      |      |
               TERM    OR     TERM
                 |      |      |
             "xapian" "OR"  "google"


The corresponding grammar rules applied in the order of application are
as follow::

	Level 1 - term ::= TERM.  term ::= TERM.
	Level 2 - prob_expr ::= term.  prob_expr ::= term.
	Level 3 - expr ::= prob_expr.  expr ::= prob_expr.
	Level 4 - bool_arg ::= expr.  bool_arg ::= expr.
	Level 5 - expr ::= bool_arg OR bool_arg.
	Level 6 - query ::= expr.

In this case, the Query object formed is::

	Query((Zxapian@1 OR Zgoogl@2))

Similarly, other boolean operators like AND, XOR etc. can be used.


Near Query
------------

Consider the following query::

	tower NEAR libery NEAR ohio

Here the tokens generated by the lexer are : TERM ("tower"), NEAR (10),
TERM ("liberty"), NEAR (10) and TERM ("ohio")

The parser then reduces the tokens in a bottom-up manner as follow::

                                     query		Level-7
                                       |
                                      expr		Level-6
                                       |
                                   prob_expr		Level-5
                                       |
                                     term		Level-4
                                       |
                                compound_term		Level-3
                                       |
                                    near_expr		Level-2
                                    /     | \
                                   /      |  \
                                  /       |   \
                                 /        |    \
                                /         |     \
                               /          |      \
                              /           |       \
                             /            |        \
                      near_expr           |         \  	Level-1
                     /    |  \            |          \
                    /     |   \           |           \
                   /      |    \          |            \
               TERM  NEAR(10)  TERM     NEAR(10)     TERM
               |       |         |        |            |
            "tower"  "NEAR"   "liberty"  "NEAR"      "ohio"

The corresponding grammar rules applied in the order of application are
as follow::

	Level 1 - near_expr ::= TERM NEAR TERM.
	Level 2 - near_expr ::= near_expr NEAR TERM.
	Level 3 - compound_term ::= near_expr.
	Level 4 - term ::= compound_term.
	Level 5 - prob_expr ::= term.
	Level 6 - expr ::= prob_expr.
	Level 7 - query ::= expr.

In this case, the Query object formed is::

	Query((tower@1 NEAR 12 libery@2 NEAR 12 ohio@3))

Phrased Query
---------------

Consider the following query::

	anonymous@xapian.org

Here ' @ ' and ' . ' are the phrase generator characters.

Here the tokens generated by the lexer are : TERM ("anonymous"), PHR_TERM
("xapian"), PHR_TERM ("org").

The parser then reduces the tokens in a bottom-up manner as follow::


                      query		Level-7
                        |
                       expr		Level-6
                        |
                      prob_expr		Level-5
                        |
                      term		Level-4
                        |
                    compound_term	Level-3
                        |
                   phrased_term		Level-2
                      /   \
                     /     \
             phrased_term   \		Level-1
                  /  \       \
                 /    \       \
                /      \       \
             TERM   PHR_TERM  PHR_TERM
               |        |       |
       "anonymous"  "xapian"  "org"


The corresponding grammar rules applied in the order of application are
as follow::

	Level 1 - phrased_term ::= TERM PHR_TERM.
	Level 2 - phrased_term ::= phrased_term PHR_TERM.
	Level 3 - compound_term ::= phrased_term.
	Level 4 - term ::= compound_term.
	Level 5 - prob_expr ::= term.
	Level 6 - expr ::= prob_expr.
	Level 7 - query ::= expr.

In this case, the Query object formed is::

	Query((anonymous@1 PHRASE 3 xapian@2 PHRASE 3 org@3))

Boolean Operator and NEAR operator
-----------------------------------

Consider the following query::

	a AND b NEAR c

Here the tokens generated by the lexer are : TERM ("a"), AND , TERM
("b"), NEAR (10), TERM ("c").

This example shows the effect of precedence of NEAR being Higher than that
of boolean operators.

The parser then reduces the tokens in a bottom-up manner as follow::


                         query 				Level-8
                           |
                          expr				Level-7
                        / |    \
                       /  |     \
                      /   |      \
                     /    |      bool_arg  		Level-6
                    /     |           |
                   /      |           |
                  /       |          expr		Level-5
                 /        |           |
            bool_arg      |         prob_expr		Level-4
                |         |           |
             expr         |           term   		Level-3
                |         |           |
           prob_expr      |          compound_term  	Level-2
                |         |                  |
              term        |                near_expr	Level-1
                |         |                /    |   \
                |         |               /     |    \
              TERM       AND         TERM  NEAR(10)  TERM
               |          |            |      |       |
              "a"       "AND"        "b"    NEAR     "c"


The corresponding grammar rules applied in the order of application are
as follow::

	Level 1 - term ::= TERM.		near_expr ::= TERM NEAR TERM.
	Level 2 - prob_expr ::= term.		compound_term ::= near_expr.
	Level 3 - expr ::= prob_expr.		term ::= compound_term.
	Level 4 - bool_arg ::= expr.		prob_expr ::= term.
	Level 5 - expr ::= prob_expr.
	Level 6 - bool_arg ::= expr.
	Level 7 - expr ::= bool_arg AND bool_arg.
	Level 8 - query ::= expr.

In this case, the Query object formed is::

	Query((Za@1 AND (b@2 NEAR 11 c@3)))



Bracketed Query and Failure of NEAR query
-------------------------------------------

Consider the following query::

	(x OR y) NEAR z

Here the tokens generated by the lexer are : TERM ("x"), GROUP_TERM
("or"), GROUP_TERM ("y"), TERM ("near"), GROUP_TERM ("z").

In this example "NEAR" does not generate a NEAR query, since the boolean
query in the expressions reduces to 'expr' and there is no grammar rule at
present that supports the NEAR query with bracketed expressions.

Under such a case, the QueryParser parses the query by turning all the
flags off. Hence the tokens '(' [BRA ], ')' [KET ] , OR and NEAR
are not detected.


The parser then reduces the tokens in a bottom-up manner as follow::


                             query					Level-8
	                       |
	                      expr					Level-7
	                       |
	                    prob_expr  					Level-6
	                       |
	                      prob					Level-5
	                    /      \
	                   /        \
	                  /          \
	                 /            \
	                /              \
                  stop_term             \                               Level-4
                    |                    \
               compound_term            stop_term                       Level-3
                    |                         |
                  group                   compound_term                 Level-2
                  /    \                      |
                 /      \                     |
              group      \		    group                       Level-1
              /  \        \                  /  \
             /    \        \                /    \
            /      \        \              /      \
         TERM   GROUP_TERM  GROUP_TERM   TERM    GROUP_TERM
 	   |       |           |           |        |
          "x"     "OR"        "y"        "near"    "z"

The corresponding grammar rules applied in the order of application are
as follow::

	Level 1 - group ::= TERM GROUP_TERM.		group ::= TERM GROUP_TERM.
	Level 2 - group ::= group GROUP_TERM.   	compound_term ::= group.
	Level 3 - compound_term ::= group.              stop_term ::= compound_term.
	Level 4 - stop_term ::= compound_term.
	Level 5 - prob ::= stop_term stop_term.
	Level 6 - prob_expr ::= prob.
	Level 7 -expr ::= prob_expr.
	Level 8 - query ::= expr.

In this case, the Query object formed is::

	Query(((Zx@1 OR or@2 OR Zy@3) OR (near@4 OR Zz@5)))



Wildcard Query
---------------

FLAG_WILDCARD should be enabled to support the Wildcard query.

Suppose our database contains the terms "code" , "coding" , "coded" ,
"coder" , "codomain" and "codomain_new" .

Consider the following query::

	cod*

Here the token generated by the lexer is : WILD_TERM ("cod")

The parser then reduces the tokens in a bottom-up manner as follow::


                query		Level-5
                  |
                 expr		Level-4
                  |
               prob_expr	Level-3
                  |
                term		Level-2
                  |
             compound_term	Level-1
                  |
               WILD_TERM
  		  |
	        "cod*"

The corresponding grammar rules applied in the order of application are
as follow::

	Level 1 - compound_term ::= WILD_TERM.
	Level 2 - term ::= compound_term.
	Level 3 - prob_expr ::= term.
	Level 4 - expr ::= prob_expr.
	Level 5 - query ::= expr.

In this case, the Query object formed is::

	Query((code@1 SYNONYM coded@1 SYNONYM coder@1 SYNONYM coding@1
	SYNONYM codomain@1 SYNONYM codomain_new@1))



Partial Query
--------------

FLAG_PARTIAL should be enabled to support the partial term query.

Suppose our database contains the terms "code" , "coding" , "coded" ,
"coder" , "codomain" and "codomain_new".

Consider the following query::

	I am a cod

Here the tokens generated by the lexer is : TERM ("i"), GROUP_TERM
("am"), GROUP_TERM ("a"), EMPTY_GROUP_OK, PARTIAL_TERM ("cod")

The parser then reduces the tokens in a bottom-up manner as follow::

				          query         			Level-10
				  	    |
				          expr		                	Level-9
					    |
				        prob_expr       			Level-8
				     	    |
				           prob			                Level-7
				          /     \
	                                 /       \
                                        /         \
	                         stop_term         \			        Level-6
                                      |             \
	                       compound_term         \			        Level-5
	                              |               \
	                            group              \                        Level-4
	                           /     \              \
                                  /       \              \
	                     group         \              \ 		        Level-3
                             /   \          \              \
                            /     \          \              \
	                 group     \          \              stop_term	        Level-2
                         /  \       \          \                    |
                        /    \       \          \            compound_term	Level-1
                       /      \       \          \                  |
                    TERM  GROUP_TERM  GROUP_TERM  EMPTY_GROUP_OK  PARTIAL_TERM
                      |        |       |                            |
                    "i"       "am"    "a"                         "cod"

The corresponding grammar rules applied in the order of application are
as follow::


	Level 1 - compound_term ::= PARTIAL_TERM.
	Level 2 - group ::= TERM GROUP_TERM.		stop_term ::= compound_term.
	Level 3 - group ::= group GROUP_TERM.
	Level 4 - group ::= group EMPTY_GROUP_OK.
	Level 5 - compound_term ::= group.
	Level 6 - stop_term ::= compound_term.
	Level 7 - prob ::= stop_term stop_term.
	Level 8 - prob_expr ::= prob.
	Level 9 - expr ::= prob_expr.
	Level 10 - query ::= expr.

In this case, the Query object formed (according to the database mentioned
above) is::

	Query(((Zi@1 OR Zam@2 OR Za@3) OR ((code@4 SYNONYM coded@4 SYNONYM
	coder@4 SYNONYM coding@4 SYNONYM codomain@4 SYNONYM codomain_new@4)
	OR Zcod@4)))


Multiple Filters Query
-----------------------

Suppose our database has the fields "site" and "description" and are prefixed
to "S" and "T" respectively::

	qp.add_boolean_prefix("site","S");
	qp.add_boolean_prefix("title","T");

Consider the following query::

	watches title:sale site:google

Here the tokens generated by the lexer are : TERM ("watches"),
BOOLEAN_FILTER ("title:sale"), BOOLEAN_FILTER ("site:google")

The parser then reduces the tokens in a bottom-up manner as follow::


                      query                         Level-8
                        |
                       expr                         Level-7
                        |
		     prob_expr		            Level-6
			|
		       prob			    Level-5
		     /	    \
                    /        \
              stop_prob       \                     Level-4
		|   	       \
	      prob		\		    Level-3
	     /	  \		 \
       stop_prob   \		  \		    Level-2
	   |        \		   \
	stop_term    \		    \  		    Level-1
           |          \              \
	 TERM     BOOLEAN_FILTER   BOOLEAN_FILTER
	   |                |               |
	"watches"	"title:sale"	"site:google"

The corresponding grammar rules applied in the order of application are
as follow::

	Level 1 - stop_term ::= TERM.
	Level 2 - stop_prob ::= stop_term.
	Level 3 - prob ::= stop_prob BOOLEAN_FILTER
	Level 4 - stop_prob ::= prob.
	Level 5 - prob ::= stop_prob BOOLEAN_FILTER
	Level 6 - prob_expr ::= prob.
	Level 7 - expr ::= prob_expr.
	Level 8 - query ::= expr.

In this case, the Query object formed (according to the database mentioned
above) is::

	Query((Zwatch@1 FILTER (Sgoogle AND Tsale)))



LOVE Query
------------

Consider the following query::

	xapian +strategy

Here the tokens generated by the lexer are : TERM ("xapian"), LOVE ,
TERM ("strategy")

The parser then reduces the tokens in a bottom-up manner as follow::



	                     query		Level-6
                               |
	                      expr		Level-5
			       |
			    prob_expr		Level-4
			       |
                              prob		Level-3
                             / |  \
                            /  |   \
	            stop_prob  |    \		Level-2
                        |      |     \
	           stop_term   |    term	Level-1
                        |      |      |
                      TERM    LOVE   TERM
                        |      |      |
                    "xapian"  "+"  "strategy"


The corresponding grammar rules applied in the order of application are
as follow::

	Level 1 - stop_term ::= TERM.             	term ::= TERM.
	Level 2 - stop_prob ::= stop_term.
	Level 3 - prob ::= stop_prob LOVE term.
	Level 4 - prob_expr ::= prob.
	Level 5 - expr ::= prob_expr.
	Level 6 - query ::= expr.

In this case, the Query object formed is::

	Query((Zstrategi@2 AND_MAYBE Zxapian@1))

Similarly, the HATE query ("like xapian -strategy") is parsed.



An Ineffective Query
----------------------

Consider the following query::

	a OR b -c

Here the expected behaviour should be (a OR b) -c, BUT the present grammar
parses it as a OR ( b -c )

This is a present bug ( `ticket #521`_ )

Here the tokens generated by the lexer are : TERM ("a"), OR , TERM
("b"), HATE , TERM ("c")

The parser then reduces the tokens in a bottom-up manner as follow::

                               query				Level-8
                                |
                               expr				Level-7
                              /|   \
                     	     / |    \
			    /  |     \
			   /   |      bool_arg			Level-6
		          /    |          |
			 /     |         expr			Level-5
			/      |	    |
		   bool_arg    |	  prob_expr		Level-4
		       |       |	      |
		     expr      |             prob		Level-3
		       |       |            / |  \
		       |       |           /  |   \
		     prob_expr |  stop_prob   |    \		Level-2
		       |       |      |       |     \
		     term      |   stop_term  |    term		Level-1
		       |       |      |       |      |
		     TERM      OR    TERM   HATE   TERM
		       |       |      |      |      |
	              "a"     "OR"   "b"    "-"    "c"

The corresponding grammar rules applied in the order of application are
as follow::

	Level 1 - term ::= TERM.	stop_term ::= TERM.	term ::= TERM.
	Level 2 - prob_expr ::= term.	stop_prob ::= stop_term.
	Level 3 - expr ::= prob_expr.	prob ::= stop_prob HATE term.
	Level 4 - bool_arg ::= expr.	prob_expr ::= prob.
	Level 5 - expr ::= prob_expr.
	Level 6 - bool_arg ::= expr.
	Level 7 - expr ::= bool_arg OR bool_arg.
	Level 8 - query ::= expr.

In this case, the Query object formed is::

	Query((Za@1 OR (Zb@2 AND_NOT Zc@3)))


Bibliography
=============

_`Lemon Parser Generator` <http://www.hwaci.com/sw/lemon/>

_`Parse`
<http://xapian.org/docs/sourcedoc/html/queryparser__internal_8cc.html#ee7aae42b4ccbfa6af14f369ccafbc69>

_`ticket #521` <http://trac.xapian.org/ticket/521>
