============================
Xapian QueryParser
============================

.. contents:: Table of contents

Introduction
============

This document is intended to provide the details of ``Xapian::QueryParser`` - the syntax and the implementation details.

The Parser is generated by `Lemon Parser Generator <http://www.hwaci.com/sw/lemon/>`_. Lemon is an LALR parser generator for C or C++. Rather than generating a complete and working program, it generates only a few subroutines that implements the parser.

The `Xapian QueryParser`_ contains a self-written lexer( descried below, in `The Lexer`_) which tokenizes the query, and each time after figuring out the type of token, calls the Lemon generated parser [to be specific, calls the method `static void Parse( yyParser * , int, Term * , State * )`_ with the token detected and the corresponding information of the token.


Lemon Generated Subroutines
===========================

The prototype and description of the four subroutines that are generated in `Xapian QueryParser`_ using Lemon are :

static yyParser * ParseAlloc()
-------------------------------

This routine allocates and initializes the new parser and returns a pointer to it.

static void ParseFree( yyParser * )
------------------------------------

This routine is used free all the memory allocated by the parser.

This is called after the program is finished using the parser. The argument to be passed is the pointer returned by `static yyParser * ParseAlloc()`_ .

static void Parse( yyParser * , int, Term * , State * )
-------------------------------------------------------

This is the main parser function. It is called each time a token is generated by the lexer.

 - The *first argument* is the pointer returned by `static yyParser * ParseAlloc()`_. 
 - The *second argument* is the integer that tells the parser the type of the token to be parsed. There is one token for each TERMINAL symbol specified in the grammar.The TERMINAL symbols are mapped to appropriate integer values.
 - The *third argument* is the value of the given token. Xapian uses a `Class Term`_ to store all the corresponding information related to the token. This class is used to pass the information about a token from lexer to parser.
 - The *fourth argument* is an instance of the `Class State`_ . It is the Parser State that is shared between the lexer and the parser. 
    Lemon provides the feature of fourth parameter that can be of any type chosen by the programmer.The parser doesn't do anything with this argument except to pass it through to action routines. This is a convenient mechanism for passing state information down to the action routines without having to use global variables.


static void yy_parse_failed( yyParser * )
-----------------------------------------

This method is specified under ``%syntax_error`` directive provided by Lemon.

When a Lemon-generated parser encounters a syntax error, it first invokes the code specified by the ``%syntax_error`` directive [ in our case, `static void yy_parse_failed( yyParser * )`_ ] . It then enters its error recovery strategy. The error recovery strategy is to begin popping the parser's stack until it enters a state where it is permitted to shift a special non-terminal symbol named ``error``. It then shifts this non-terminal and continues parsing. But the ``%syntax_error`` routine will not be called again until at least three new tokens have been successfully shifted.

If the parser pops its stack until the stack is empty, and it still is unable to shift the error symbol, then the ``%parse_failed`` routine is invoked and the parser resets itself to its start state, ready to begin parsing a new file.





The Parser Grammar
===================

In Lemon,ALL Terminals must have the same type (as mentioned above, in Xapian, each terminal has the type `Class Term`_ thus all the information corresponding to a token is stored in the corresponding Term object) but Non-Terminals can have their own (different) types/values.


TERMINALS
----------

In Lemon a terminal symbol (token) is any string of alphanumeric and underscore characters that begins with an upper case letter. 

The QueryParser grammar has the following 23 TERMINALS : 

ERROR
~~~~~~

Used to represent an error in the query i.e. a malformed query. 

For Example, the Boolean Operators (AND, OR etc. ) require the syntax of the query to be of type ``<expression> Operator <expression>``, if it is not so, then that corresponds to `ERROR`_ 


OR
~~~
Refers to OR operator ( Xapian::Query::OP_OR ).

Example Query : ``subquery1 OR subquery2``. 

This matches the documents which are matched by either of the subqueries.

Details of Xapian::Query::OP_OR
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Consider ``A OP_OR B``

Which Documents are Passed ?
 Passes documents which match query A or B (or both)
How is the Weight of the Documents Adjusted ?
 Passes documents with the sum of weights from A and B

XOR
~~~~~~
Refers to OR operator ( Xapian::Query::OP_XOR ).

Example Query : ``subquery1 XOR subquery2``. 

This matches the documents which are matched by one or the other subquery, but not both.

Details of Xapian::Query::OP_XOR
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Consider ``A OP_XOR B``

Which Documents are Passed ?
 Passes documents which match query A or B (but not both)
How is the Weight of the Documents Adjusted ?
 Passes documents with the weight from A or B, depending which one it matches.

AND
~~~~~~
Refers to XOR operator ( Xapian::Query::OP_AND ).

Example Query : ``subquery1 OR subquery2``. 

This matches the documents which are matched by both the subqueries.

Details of Xapian::Query::OP_AND
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Consider ``A OP_AND B``

Which Documents are Passed ?
 Passes documents which match both query A and B
How is the Weight of the Documents Adjusted ?
 Passes documents with the sum of weights from A and B

NOT
~~~~~~
Refers to NOT operator ( Xapian::Query::OP_AND_NOT ).

Example Query : ``subquery1 NOT subquery2``.

Another Example Query :  ``subquery1 AND NOT subquery2``.

This matches the documents that are matched only by first subquery and not the second subquery. 

If FLAG_PURE_NOT is enabled, then queries like ``NOT subquery`` can be used. This matches the documents that are not matched by the subquery.

Details of Xapian::Query::OP_AND_NOT
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Consider ``A OP_AND_NOT B``

Which Documents are Passed ?
 Passes documents which match query A but not B
How is the Weight of the Documents Adjusted ?
 Passes documents with the weight from A only


NEAR
~~~~~~
Refers to NEAR operator ( Xapian::Query::OP_NEAR ).

Example Query : ``word1 NEAR word2``. 

This matches documents containing the both the words - word1 and word2 such that they are within 10 words of each other. The default value of NEAR operator is 10. 

We can change the default value by using NEAR/n which corresponds to the token ``NEAR(N)``. 

Example Query : ``word1 NEAR/5 word2``. 

This matches documents containing the both the words - word1 and word2 such that they are within 5 words of each other.

Details of Xapian::Query::OP_NEAR
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Consider ``A OP_NEAR B``

Which Documents are Passed ?
 Passes documents which matches A within 10 words(if default value i.e. 10 is used) of B.
How is the Weight of the Documents Adjusted ?
 Passes the matched documents with the weight of A+B

ADJ
~~~~

ADJ is similar to NEAR with the difference that it matches ONLY IF the words specified in the query with ADJ operator appear in ***same order*** as mentioned in the query.

For Example, if I have a document containing "``xapian parser provides a new stemming strategy``". 

Then both the queries "``xapian NEAR strategy``" and "``strategy NEAR xapian``" will match this document. Also "``xapian ADJ strategy``" will match this document but "``strategy ADJ xapian``" will NOT MATCH this document. 

Similar to NEAR the default value of ADJ is 10. It can be changed to n by a query like following: ``word1 ADJ/n word2``. The ADJ/n corresponds to ``ADJ(n)`` token.


LOVE
~~~~

If ``FLAG_LOVEHATE`` is enabled then "``+``" after a whitespace or an open bracket corresponds to the token ``LOVE`` but with following conditions:

 - If "+" is followed by space, then it is ignored. 
    For Example, the query  "``xapian +strategy``" returns the Query object "``strategy@2 AND_MAYBE xapian@1``" Since in this case the token LOVE is detected.

    But the query "``xapian + strategy``" returns the Query object "``xapian@1 OR strategy@2``" because here the "+" is followed by a whitespace and thus not detected as a LOVE token.

 - A Postfix "+" (such as in google+) is not treated as a LOVE token. 
    Under such case, the character "+" is regarded as a part of the term only by the lexer. 

    E.g. The query "``profile google+``" returns the query object "``profile@1 OR google+@2``" i.e. "+" is treated as the part of the term google only and not as a separate token.
 - Ignored if present at the end of the query. 

*Example query which involve LOVE token* : As mentioned above, the query "xapian +strategy" returns the query object "strategy@2 AND_MAYBE xapian@1". 

Xapian::Query::OP_AND_MAYBE corresponds to the AND_MAYBE operator.


Details of Xapian::Query::OP_AND_MAYBE
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Consider ``A OP_AND_MAYBE B``
 
Which Documents are Passed?
 Passes documents which matches A or (A and B).
How is the Weight of Documents Adjusted?
 Documents which match A and B are passed, with weight of A+B

 Documents which match A only are passed, with weight of A

 Documents which match B only are not passed


HATE
~~~~
If ``FLAG_LOVEHATE`` is enabled then "``-``" after a whitespace or an open bracket corresponds to the token HATE but with the following conditions:

 - If "-" is followed by space, then it is ignored. 
    For Example, The query "``xapian -strategy``" returns the Query object "xapian@1 AND_NOT strategy@2" since in this case the token HATE is detected.
   
    But the query "``xapian - strategy``" returns the Query object "``xapian@1 OR strategy@2``" because here the "-" is followed by a whitespace and thus not detected as a HATE token.

 - A Postfix - (such as in xapian-) is not treated as a HATE token. 
    Under such case, the character "-" is simply ignored by the lexer and is not regarded as a part of the term.
  
    E.g. The query "``xapian- core``" returns the query object "``xapian@1 OR core@2``" i.e. "-" is simply ignored and is not treated as the part of the term xapian or as a separate token.

 - Ignored if present at the end of the query. 

*Example query which involve HATE token* : As mentioned above, the query "``xapian -strategy``" returns the query object "``xapian@1 AND_NOT strategy@2``". 

Xapian::Query::OP_AND_NOT corresponds to the AND_NOT operator.

Details of Xapian::Query::OP_AND_NOT
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Consider A OP_AND_NOT B 
 
Which Documents are Passed? 
 Passes the documents which match query A but not B.
How is the Weight of Documents Adjusted?
 Passes documents with the weight from A only.


HATE_AFTER_AND
~~~~~~~~~~~~~~~
If ``FLAG_LOVEHATE`` is enabled then "``-``" after AND operator corresponds to the token HATE_AFTER_AND.


SYNONYM
~~~~~~~~
If ``FLAG_SYNONYM`` is enabled then "``~``" after a whitespace, +, -, or an open bracket corresponds to the token SYNONYM but with the following conditions:

 - It is ignored if not followed by a word character. 
    E.g. Consider the database in ehich we have specified  "``happy``" and "``cheerful``" as synonyms.

    Then the query "``~happy``" will return the Query object "``happy@1 SYNONYM cheerful@1``" since here the token SYNONYM has been detected.

    But the query "``~ happy``" returns the Query object "``happy@1``" since here the "-" is followed by a whitespace and thus not detected as a SYNONYM token.
 - Ignored if present at the end of the query.


*Example query which involve SYNONYM token* 

**NOTE**: we must call `set_database() <http://xapian.org/docs/sourcedoc/html/classXapian_1_1QueryParser.html#010f2b63522f063aa3b5f5645479d9e9>`_ for this to work. Also we need to add the synonyms to the document. This can be done as follow::

    Xapian::WritableDatabase db(@param);
    db.add_synonym("happy", "cheerful");
    Xapian::QueryParser qp;
    qp.set_database(db);

Now if we give a query "``~happy``" then the Query object returned is "``happy@1 SYNONYM cheerful@1``". 

Xapian::Query::OP_SYNONYM corresponds to the SYNONYM operator.

Details of Xapian::Query::OP_SYNONYM
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Treats a set of queries as synonyms. It is identical to OP_OR except for the weightings returned.

Which Documents are Passed? : 
 Passes documents that match at least one of the queries.
How is the Weight of Documents Adjusted?
 Documents are weighted as if all the sub-queries are are instances of the same term, so multiple matching terms increase the wdf value used, and the term frequency is based on the number of documents which will match an OR of all the subqueries.

TERM
~~~~~
TERM is a query term, including prefix (if any).

GROUP_TERM
~~~~~~~~~~~
GROUP_TERM is a query term which follows a TERM or another GROUP_TERM and is only separated by whitespace characters.

PHR_TERM
~~~~~~~~~
PHR_TERM is a query term which follows a TERM or another PHR_TERM and is separated only by one or more phrase generator characters (hyphen and apostrophe are common examples).

Phrase generator characters (tested via `is_phrase_generator() <http://xapian.org/docs/sourcedoc/html/queryparser__internal_8cc.html#ab60021d249d420797bf71899944a5d3>`_ ) are the characters that generate a phrase search.

Currently Xapian supports the following characters as phrase generator::

    "." , "-" , "/" , ":" , "\\" , "@"

The phrase operator allows for searching for a specific phrase and returns only matches where all terms appear in the document, in the correct order, giving a weight of the sum of each term.

For example : The query object "``a@1 PHRASE 3 b@2 PHRASE 3 c@3``" matches the documents which match A followed by B followed by C and gives them a weight of A+B+C.

.. _above:

*Examples of phrase search* : 
 
 - The query : "``xapian.org``" ,returns the Query object "``xapian@1 PHRASE 2 org@2``" (since "." is a phrase generator)
 - The query: "``A B C``" , returns the Query object "``a@1 PHRASE 3 b@2 PHRASE 3 c@3``" whereas the query : "``A B C``" , returns the Query object "``a@1 OR b@2 OR c@3``".
 - The query : "``/home/user/xapian/xapian-core``" , returns the Query object "``home@1 PHRASE 5 user@2 PHRASE 5 xapian@3 PHRASE 5 xapian@4 PHRASE 5 core@5``".

Phrase search also plays an important role with the filters. 

For Example suppose we add the filter (non-boolean) for field "``title``" by mapping it to prefix "``T``" (by doing ``qp.add_prefix("title","T")``), 

Then the query -  ``title:"Harry Potter and the Chamber of Secrets"`` , returns the Query object "``Tharry@1 PHRASE 7 Tpotter@2 PHRASE 7 Tand@3 PHRASE 7 Tthe@4 PHRASE 7 Tchamber@5 PHRASE 7 Tof@6 PHRASE 7 Tsecrets``" i.e. the whole title is treated as a single entity since the words are connected by ``OP_PHRASE`` and also that all words are prefixed by "T". 

Whereas the query -  ``title:Harry Potter and the Chamber of Secrets`` , returns the Query object "``Tharry@1 OR potter@2 OR and@3 OR the@4 OR chamber@5 OR of@6 OR secrets@7``" i.e. the whole title is not treated as a single entity since the words are connected by OP_OR and also all words are not prefixed by "T".

**Note**: For the phrase searches, FLAG_PHRASE should be enabled. (By default it is enabled)

Details of Xapian::Query::OP_PHRASE
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Consider A OP_PHRASE B OP_PHRASE C

Which Documents are Passed? : 
 Passes documents that match A followed by B followed by C.
How is the Weight of Documents Adjusted?
 Matched documents are are given a weight of A+B+C.

WILD_TERM
~~~~~~~~~
WILD_TERM is like a TERM, but has a trailing wildcard which needs to be expanded. It is used to match any number of trailing characters within a term (Right Truncation).

**Note**: Like in the case of synonyms, for the wildcard expansion we must call `set_database() <http://xapian.org/docs/sourcedoc/html/classXapian_1_1QueryParser.html#010f2b63522f063aa3b5f5645479d9e9>`_. Also the wildcard expansion works ONLY IF ``FLAG_WILDCARD`` is enabled. (By default, it is not enabled). 

You can limit the number of terms a wildcard will expand to by calling `Xapian::QueryParser::set_max_wildcard_expansion() <http://xapian.org/docs/sourcedoc/html/classXapian_1_1QueryParser.html#8e2bcb09952fbb2b713ef61e8eb6f638>`_. 

If a wildcard expands to more terms than that number, an exception will be thrown. The exception may be thrown by the QueryParser, or later when Enquire handles the query. The default is not to limit the expansion.

*Example of wildcard query* : 

Consider our database contains the terms "code" , "coding" , "coded" , "coder" , "codomain" and "codomain_new" .

Then the query "``cod*``" will return the Query object "``code@1 SYNONYM coded@1 SYNONYM coder@1 SYNONYM coding@1 SYNONYM codomain@1 SYNONYM codomain_new@1``".


PARTIAL_TERM
~~~~~~~~~~~~~
PARTIAL_TERM is like a TERM, but it's at the end of the query string and we're doing "search as you type". It refers to the final term of a partial match query, with no following characters and is thus treated as a wildcard, thus expands to something like WILD_TERM. 

Partial matching causes the parser to treat the query as a "*partially entered*" search. 


This will automatically treat the final word as a wildcard match, unless it is followed by whitespace, to produce more stable results from interactive searches.

**Note** : ``FLAG_PARTIAL`` should be enables to support the partial term query

*Example of partial term query* : 
Consider the same database as used above in wildcard query. Our database contains the terms "code" , "coding" , "coded" , "coder" , "codomain" and "codomain_new".

Then the query "``I am a cod``" will treat the last word of the query ("``cod``") as wildcard term and thus return the following Query object 

"``(i@1 OR am@2 OR a@3) OR ((code@4 SYNONYM coded@4 SYNONYM coder@4 SYNONYM coding@4 SYNONYM codomain@4 SYNONYM codomain_new@4) OR cod@4)``"

    The problem with this kind of search is that the last word in a partially entered query often has no semantic relation to the completed word. For example, a search for "``dynamic cat``" would return a quite different set of results to a search for "``dynamic categorisation``". This results in the set of results displayed flicking rapidly as each new character is entered. A much smoother result can be obtained if the final word is treated as having an implicit terminating wildcard, so that it matches all words starting with the entered characters - thus, as each letter is entered, the set of results displayed narrows down to the desired subject.

    A similar effect could be obtained simply by enabling the wildcard matching option, and appending a "*" character to each query string. However, this would be confused by searches which ended with punctuation or other characters.


BOOLEAN_FILTER
~~~~~~~~~~~~~~~

BOOLEAN_FILTER is a query term with a prefix registered using `add_boolean_prefix() <http://xapian.org/docs/sourcedoc/html/classXapian_1_1QueryParser.html#411cc8253c599b7d877749b8e814ee76>`_ . It's added to the query using an OP_FILTER operator,(or OP_AND_NOT if it's negated) for example,  ``site:xapian.org`` or ``-site:xapian.org``. These were explained in detail along with examples earlier while describing the different types of filters, through `filter_type type`_

RANGE
~~~~~
This token corresponds to a Range search.

The QueryParser supports range searches on document values, matching documents which have values within a given range. There are several types of range processors available.

To use a range, additional programming is required to tell the QueryParser what format a range is specified in and which value is to be searched for matches within that range. This then gives rise to the ability to specify ranges as:

$10..50 5..10kg 01/01/1970..01/03/1970 size:3..7

When date ranges are configured (as a DateValueRangeProcessor), you can configure which format dates are to be interpreted as (i.e. month-day-year) or otherwise.

QUOTE
~~~~~~
Characters ' ``"`` ' , left curly double quote(0x201c) and the right curly double quote(0x201d) match to the token QUOTE. 

An unmatched " at the end of the query is ignored to avoid generating an empty pair of QUOTEs which will cause a parse error. 

The grammar rule corresponding to the phrased searched is : **QUOTE phrase(P) QUOTE**. Examples of phrased search were given above_ .

BRA
~~~~
Character '``(``' after a whitespace, bracket , '+' or '-' matches to the token BRA with the following conditions:

 - It is ignored if present at the end of the query.
 - It is ignored if the case corresponds to empty ().

The grammar rule corresponding to the bracketed expression is : **compound_term ::= BRA expr KET** 

KET
~~~~
Character '``)``' represents the token KET. It represents the end of a bracketed expression.

The grammar rule corresponding to the bracketed expression is : **compound_term ::= BRA expr KET**

CJKTERM
~~~~~~~~
It corresponds to the case if CJK n-gram code is being used i.e. if `CJK::is_cjk_enabled() <http://xapian.org/docs/sourcedoc/html/namespaceCJK.html#6d76ede0fd2a9ad3a12532d63c05caee>`_  is true and `CJK::codepoint_is_cjk(*itertor) <http://xapian.org/docs/sourcedoc/html/namespaceCJK.html#efab5934f6a82a989b994fad5068670d>`_  returns true.

EMPTY_GROUP_OK
~~~~~~~~~~~~~~~
This token corresponds to the end of a `group`_ (a non-terminal, explained later), where group refers to a group of terms separated only by whitespace - candidates for multi-term synonyms

The corresponding grammar rule is : **group ::= group EMPTY_GROUP_OK**



NON-TERMINALS
--------------

The QueryParser grammar has the following 14 NON-TERMINALS (as mentioned earlier, in Lemon, non-terminals can have different type/value):

query
~~~~~~

**Type**  :  query {int}

The whole query - just an expr or nothing.

The corresponding grammar rules and their description are as follow along with the pseudo code:

 - **query ::= expr(E).**

   The parsed query is saved in `Class State`_ structure::

    { state->query = *E }

 - **query ::= .**

   If it is nothing, then point to empty query::

    { state->query = Query() }


expr
~~~~~ 
**Type** : expr {Query * }

expr - A query expression.

The corresponding grammar rules and their description are as follow along with the pseudo code:

 - **expr(E) ::= prob_expr(P).** 
   
   Assign E equal to P.::

    { E = P }

 - **expr(E) ::= bool_arg(A) AND bool_arg(B).**
   
   Two bool_arg with AND operator in between them. Neither A nor B should be null.::

    { E = new Query(OP_AND, *A, *B); }

 - **expr(E) ::= bool_arg(A) NOT bool_arg(B).** 
   
   Two bool_arg with NOT operator in between them. If ``FLAG_PURE_NOT`` is enabled, then A can be null, otherwise neither A nor B should be null.::

    { E = new Query(OP_AND_NOT, *A, *B); }

 - **expr(E) ::= bool_arg(A) AND NOT bool_arg(B).** 
   
   Two bool_arg with AND NOT in between them. Neither A nor B should be null.::

    { E = new Query(OP_AND_NOT, *A, *B); }

 - **expr(E) ::= bool_arg(A) AND HATE_AFTER_AND bool_arg(B).**
   
   Two bool_arg with AND '-' in between them. Neither A nor B should be null.::

    { E = new Query(OP_AND_NOT, *A, *B); }

 - **expr(E) ::= bool_arg(A) OR bool_arg(B).** 
   
   Two bool_arg with OR in between them. Neither A nor B should be null.::

    { E = new Query(OP_OR, *A, *B); }

 - **expr(E) ::= bool_arg(A) XOR bool_arg(B).** 
   
   Two bool_arg with OR in between them. Neither A nor B should be null.::

    { E = new Query(OP_XOR, *A, *B); }


bool_arg
~~~~~~~~~

**Type** : bool_arg {Query * }

bool_arg - an argument to a boolean operator such as AND or OR.

The corresponfing grammar rules and their description are as follow along with the pseudo code:

 - **bool_arg(A) ::= expr(E).** 
   
   Assign A equal to E::

    { A = E; }

 - **bool_arg(A) ::= .** 
   
   This case corresponds to ERROR since boolean operators require two terms. Set the argument to NULL, which enables the bool_arg-using rules in expr above to report uses of AND, OR, etc which don't have two arguments::

    { A = NULL; }


prob_expr
~~~~~~~~~~
**Type** : prob_expr {Query * }

prob_expr - a single compound term, or a prob.

The corresponding grammar rules are :

 - **prob_expr(E) ::= prob(P).** 

 - **prob_expr(E) ::= term(T).** 


prob
~~~~~
**Type** :  prob {`ProbQuery * <http://xapian.org/docs/sourcedoc/html/structProbQuery.html>`_}

prob - a probabilistic sub-expression consisting of stop_terms, "+" terms, "-" terms, boolean filters, and/or value ranges.

The corresponding grammar rules are:

 - **prob(P) ::= RANGE(R).**

 - **prob(P) ::= stop_prob(Q) RANGE(R).** 

 - **prob(P) ::= stop_term(T) stop_term(U).**

 - **prob(P) ::= prob(Q) stop_term(T).**

 - **prob(P) ::= LOVE term(T).**

 - **prob(P) ::= stop_prob(Q) LOVE term(T).** 

 - **prob(P) ::= HATE term(T).** 

 - **prob(P) ::= stop_prob(Q) HATE term(T).** 

 - **prob(P) ::= HATE BOOLEAN_FILTER(T).** 

 - **prob(P) ::= stop_prob(Q) HATE BOOLEAN_FILTER(T).**

 - **prob(P) ::= BOOLEAN_FILTER(T).** 

 - **prob(P) ::= stop_prob(Q) BOOLEAN_FILTER(T).** 

 - **prob(P) ::= LOVE BOOLEAN_FILTER(T).**
   
   LOVE BOOLEAN_FILTER(T) is just the same as BOOLEAN_FILTER. 


stop_prob
~~~~~~~~~~
**Type** : stop_prob {ProbQuery * }

stop_prob - A prob or a stop_term.

The corresponding grammar rules are :

 - **stop_prob(P) ::= prob(Q).**
 - **stop_prob(P) ::= stop_term(T).**


stop_term
~~~~~~~~~~~
**Type** : stop_term {Query * }

stop_term - A term which should be checked against the stopword list, or a compound_term.

If a term is loved, hated, or in a phrase, we don't want to consult the stopword list, so stop_term isn't used there (instead term is).

The corresponding grammar rules are :

 - **stop_term(T) ::= TERM(U).** 

 - **stop_term(T) ::= compound_term(U).**


term 
~~~~~
**Type** : term {Query * }

term - A term or a compound_term. 

It is different from stop_term in the sense that here we don't consult the stopword list. 

This corresponds to the case if the term is loved, hated, or in a phrase.

The corresponding grammar rules are :

 - **term(T) ::= TERM(U).** 
 - **term(T) ::= compound_term(U).**


compound_term
~~~~~~~~~~~~~~
Type : compound_term {Query * }

compound_term - A WILD_TERM, a quoted phrase (with or without prefix), a phrased_term, group, near_expr, adj_expr, or a bracketed subexpression (with or without prefix).

The corresponding grammar rules are :

 - **compound_term(T) ::= WILD_TERM(U).**
 - **compound_term(T) ::= PARTIAL_TERM(U).**
 - **compound_term(T) ::= QUOTE phrase(P) QUOTE.** 
 - **compound_term(T) ::= phrased_term(P).** 
 - **compound_term(T) ::= group(P).** 
 - **compound_term(T) ::= near_expr(P).** 
 - **compound_term(T) ::= adj_expr(P).** 
 - **compound_term(T) ::= BRA expr(E) KET.**
 - **compound_term(T) ::= SYNONYM TERM(U).**       
 - **compound_term(T) ::= CJKTERM(U).**

phrase
~~~~~~~
**Type** :  phrase {Terms * }

phrase - The "inside the quotes" part of a double-quoted phrase.

The corresponding grammar rules are :

 - **phrase(P) ::= TERM(T).**
 - **phrase(P) ::= CJKTERM(T).** 
 - **phrase(P) ::= phrase(Q) TERM(T).**

  
phrased_term
~~~~~~~~~~~~~
A phrased term works like a single term, but is actually 2 or more terms linked together into a phrase by punctuation. There must be at least 2 terms in order to be able to have punctuation between the terms.

The corresponding grammar rules are :

 - **phrased_term(P) ::= TERM(T) PHR_TERM(U).**
 - **phrased_term(P) ::= phrased_term(Q) PHR_TERM(T).**


group
~~~~~~
**Type** : group {TermGroup * }

group - A group of terms separated only by whitespace - candidates for multi-term synonyms.

The corresponding grammar rules are :

 - **group(P) ::= TERM(T) GROUP_TERM(U).**
 - **group(P) ::= group(Q) GROUP_TERM(T).**
 - **group(P) ::= group(Q) EMPTY_GROUP_OK.**


near_expr
~~~~~~~~~~
**Type** : near_expr {Terms * }

near_expr - 2 or more terms with NEAR in between. There must be at least 2 terms in order for there to be any NEAR operators.

The corresponding grammar rules are :

 - **near_expr(P) ::= TERM(T) NEAR(N) TERM(U).**
 - **near_expr(P) ::= near_expr(Q) NEAR(N) TERM(T).** 


adj_expr
~~~~~~~~~
**Type** adj_expr {Terms * }

adj_expr - 2 or more terms with ADJ in between. There must be at least 2 terms in order for there to be any ADJ operators. 

The corresponding grammar rules are :

 - **adj_expr(P) ::= TERM(T) ADJ(N) TERM(U).**
 - **adj_expr(P) ::= adj_expr(Q) ADJ(N) TERM(T).** 


Grammar Rules
--------------

Following are the grammar rules of QueryParser , listed together in the order :

0.  query ::= expr.

1.  query ::= .

2.  expr ::= prob_expr.

3.  expr ::= bool_arg AND bool_arg.

4.  expr ::= bool_arg NOT bool_arg.

5.  expr ::= bool_arg AND NOT bool_arg.

6.  expr ::= bool_arg AND HATE_AFTER_AND bool_arg.

7.  expr ::= bool_arg OR bool_arg.

8.  expr ::= bool_arg XOR bool_arg.

9.  bool_arg ::= expr.

10. bool_arg ::= . 

11. prob_expr ::= prob.

12. prob_expr ::= term.

13. prob ::= RANGE.

14. prob ::= stop_prob RANGE.

15. prob ::= stop_term stop_term.

16. prob ::= prob stop_term.

17. prob ::= LOVE term.

18. prob ::= stop_prob LOVE term.

19. prob ::= HATE term.

20. prob ::= stop_prob HATE term.

21. prob ::= HATE BOOLEAN_FILTER.

22. prob ::= stop_prob HATE BOOLEAN_FILTER.

23. prob ::= BOOLEAN_FILTER.

24. prob ::= stop_prob BOOLEAN_FILTER.

25. prob ::= LOVE BOOLEAN_FILTER.

26. prob ::= stop_prob LOVE BOOLEAN_FILTER.

27. stop_prob ::= prob.

28. stop_prob ::= stop_term.

29. stop_term ::= TERM.

30. stop_term ::= compound_term.

31. term ::= TERM.

32. term ::= compound_term.

33. compound_term ::= WILD_TERM.

34. compound_term ::= PARTIAL_TERM.

35. compound_term ::= QUOTE phrase QUOTE.

36. compound_term ::= phrased_term.

37. compound_term ::= group.

38. compound_term ::= near_expr.

39. compound_term ::= adj_expr.

40. compound_term ::= BRA expr KET.

41. compound_term ::= SYNONYM TERM.

42. compound_term ::= CJKTERM.

43. phrase ::= TERM.

44. phrase ::= CJKTERM.

45. phrase ::= phrase TERM.

46. phrase ::= phrase CJKTERM.

47. phrased_term ::= TERM PHR_TERM.

48. phrased_term ::= phrased_term PHR_TERM.

49. group ::= TERM GROUP_TERM.

50. group ::= group GROUP_TERM.

51. group ::= group EMPTY_GROUP_OK.

52. near_expr ::= TERM NEAR TERM.

53. near_expr ::= near_expr NEAR TERM.

54. adj_expr ::= TERM ADJ TERM.

55. adj_expr ::= adj_expr ADJ TERM.





Important Classes used in the implementation of QueryParser
============================================================


Class Term
------------
This is the type of all the TERMINAL tokens in the QueryParser grammar.

This is the third argument passed to `static void Parse( yyParser * , int, Term * , State * )`_ .

`Xapian QueryParser`_ uses this class to store all the corresponding information related to the token.
This class is used to pass the information about a token from lexer to parser.

Generally an instance of this class carries term information, but it can be used for the start or end of a value range, with some operators (e.g. the distance in NEAR/3 or ADJ/3, etc).

It has six basic attributes :

State * state
~~~~~~~~~~~~~~
`Class State`_ is defined by QueryParser to maintain the information of state, across the parser and lexer, thus avoiding the use of global variables. It is the same as the 4th argument of the `static void Parse( yyParser * , int, Term * , State * )`_


string name
~~~~~~~~~~~~
It represents the word string present in the query corresponding to the token generated by the lexer.

For example, for the input query : ``latest watches`` , two tokens shall be generated by the lexer, one corresponding to the string "``latest``" and other corresponding to the string "``watches``". 

Let term1 and term2 be the Term objects corresponding to the values of the two tokens respectively. 

Then term1.name will be "``latest``" and term2.name will be "``watches``". 

It is used by `make_term() <http://xapian.org/docs/sourcedoc/html/classTerm.html#bb567cf8d22cfcf01921aee00eae9e68>`_    when making a term by appending the prefixes, "Z" etc. (IF required) to the ``Term::name``.


const PrefixInfo * prefix_info
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PrefixInfo is a struct defined in queryparser_internal.h (line 42). It contains information about how to handle a prefix in a query string.

Two main members of struct PrefixInfo? are

filter_type type
^^^^^^^^^^^^^^^^^^
Defined queryparser_internal.h (line 39). It describes the type of the filter. It can have 3 values

NON_BOOLEAN
''''''''''''''
Represents a probabilistic term prefix.

For example, Suppose we have a large database corresponding to different sites, such that the documents with different sites have "``site``" field associated with them.
Let us map the field "``site``" to prefix "``S``" 

This prefix can be added by the following code::

    Xapian::QueryParser : qp; 
    qp.add_prefix("site","S");

Now consider the following query::

    watches site:google 

The above query will return the following Query object::

    watches@1 OR Agoogle 


Multiple fields can be mapped to SAME prefix. 

For example, Suppose our database have a field "``title``" along with with the field "``site``".

Let us map the field "site" to the same prefix as before, i.e. "S" and field "title" to the also to the prefix "S"::

    qp.add_prefix("site","S");
    qp.add_prefix("title","S");

Now consider the following query::

    watches site:google title:sale''

The above query will return the following Query object::

    watches@1 OR Sgoogle@2 OR Ssale@3


It is also possible to map a single field with to MULTIPLE prefixes. 

Multiples terms are generated for such a field, combined with Xapian::Query::OP_OR.

For example, Let us map the field "site" to prefix "S" as well as prefix "T"::

    qp.add_prefix("site","S");
    qp.add_prefix("site","T");

Now consider the following query::

    watches site:google

The above query will return the following Query object::

    watches@1 OR (Sgoogle@2 OR Tgoogle@2)


BOOLEAN_EXCLUSIVE
''''''''''''''''''
It allows the user to restrict a search with a boolean filter specified in the free text query.

For example, Consider the same database as in previous example.
Now suppose we make the field "``site``" a Boolean filter::

    qp.add_boolean_prefix("site","S")

Now consider the following query::

    watches site:google

The above query will return the following Query object::

    watches@1 FILTER Sgoogle

The corresponding search will return all the documents from site google ONLY (and not any other site since we made "site" a boolean filter) which have the term "watches" in it. 

The operator ``OP_FILTER`` (corresponding to FILTER ) is used (and not OP_OR) since the type of prefix is BOOLEAN_EXCLUSIVE.

If there are boolean filters for different prefixes, they will be combined with the @c Xapian::Query::OP_AND operator.

For example, Consider the same database with the fields "site" and "description". 

Let us make both of these boolean filters with DIFFERENT prefixes::
    
    qp.add_boolean_prefix("site","S");
    qp.add_boolean_prefix("title","T");

Now consider the following query::

    watches site:google title:sale

The above query will return the following Query object::

    watches@1 FILTER (Sgoogle AND Tsale).

If multiple boolean filters are specified in a query for the same prefix, they will be combined with the Xapian::Query::OP_OR operator.

For example, Consider the same database with the fields "``site``" and "``description``". 

Let us make both of these boolean filters with SAME prefixes::

    qp.add_boolean_prefix("site","S");
    qp.add_boolean_prefix("title","S");

Now consider the following query::

    watches site:google title:sale

The above query will return the following Query object::

    watches@1 FILTER (Sgoogle OR Ssale)


Details of Xapian::Query::OP_FILTER
````````````````````````````````````
Consider A OP_FILTER B

What Documents are Passed?
 Passes documents which match both the subqueries A as well as B 

How is the Weights of Documents Adjusted?
 Passes documents with the weight from A ONLY.


BOOLEAN 
'''''''''
It is same as BOOLEAN_EXCLUSIVE in all respects with only one difference.

Under this type, multiple boolean filters specified for SAME prefixes are combined with OP_AND (and not with OP_OR as is the case in BOOLEAN_EXCLUSIVE type).

For example, Consider the same database with the fields "site" and "description". 

Let us make both of these boolean filters with SAME prefixes::

    qp.add_boolean_prefix("site","S");
    qp.add_boolean_prefix("title","S",true);

Now consider the following query::

    watches site:google title:sale

The above query will return the following Query object::

    watches@1 FILTER (Sgoogle AND Ssale)

list<string> prefixes
^^^^^^^^^^^^^^^^^^^^^^^

This contains the list of the prefixes corresponding to a filter.

For example, If we map the filter "site" to two prefixes "S" and "T", then the corresponding list<string> prefixes will have two terms "S" and "T". 

To manage different fields and correspondingly different prefixes associated with them, Xapian uses `map<string, PrefixInfo?> Xapian::QueryParser::Internal::prefixmap <http://xapian.org/docs/sourcedoc/html/classXapian_1_1QueryParser_1_1Internal.html#c12c981e73ccf9a157456926ae42cb50>`_ , which maps different filters to their corresponding prefix(es) and the type of filter(`filter_type type`_) via `const PrefixInfo * prefix_info`_ .


string unstemmed
~~~~~~~~~~~~~~~~~
It contains the same information as ``Term::name``, with the difference that ``Term::name`` is lowercase version of ``Term::unstemmed``.


QueryParser::stem_strategy stem
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
It represents the stemming strategy to be used by the QueryParser.

It can have three different values.

STEM_NONE 
^^^^^^^^^^
No term is stemmed.

STEM_SOME
^^^^^^^^^^
Stem terms except when used with position operators. (Note: stemmed words have a prefix "Z")

STEM_ALL  
^^^^^^^^^
All terms are stemmed. (Note: stemmed words *DON'T* have a prefix "Z")

STEM_ALL_Z [**Not Yet Added**]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
All terms are stemmed. (Note: stemmed words have a prefix "Z")


termpos pos
~~~~~~~~~~~~
It is used to keep track of the term position within the query. This is used to implement phrase searching and the NEAR operator.




Class State
-----------
This corresponds to the Parser state shared between the lexer and the parser.

This is the fourth argument passed to `static void Parse( yyParser * , int, Term * , State * )`_. Lemon doesn't do anything with this argument except to pass it through to action routines. This is a convenient mechanism for passing state information down to the action routines without having to use global variables.

It has four basic attributes :

Query query
~~~~~~~~~~~~
It is used to save the parsed query so that it can be returned. 

Thus we don't need a global parameter to save the query returned by the parser.

The highest level in the parse tree corresponds to the grammar rule : **query ::= expr(E).** where E is the parsed query. Under this rule the action taken is to save the parsed query in the State structure::

    state->query = *E;

const char* error
~~~~~~~~~~~~~~~~~~~
It is used to store the type of error if the Parser fails. Thus we don't need a global parameter to store the type of error occurred.

For example, for a query like "``A AND B``", boolean operators like OP_AND require that both A as well as B are not null. Thus if we give a query like "``spectacles AND``", then that returns the ``QueryParserError: Syntax: <expression> AND <expression>``

unsigned flags
~~~~~~~~~~~~~~~
It is used to store the information regarding the types of `Xapian::QueryParser::feature_flag <http://xapian.org/docs/sourcedoc/html/classXapian_1_1QueryParser.html#e96a58a8de9d219ca3214a5a66e0407e>`_ , that have been enabled while parsing the query.

While parsing, and tokenizing, ``state->flags`` provide a convenient way to access which all flags have been enabled, thus saving the need of global parameter.

QueryParser::Internal * qpi
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
It enables the parser to access as well as store different information and correspondingly update the attributes of ``Xapian::QueryParser::Internal``, while parsing. 

For example, If we are doing a widcard query, like "``cod*``" or a synonym query, then parser reuqires access to the database to form the Query object. Under situations like these, the parser, while parsing can access the database via qpi::

    database = qi->db;



The Lexer
==========

QueryParser has a self written lexer which iterates through the input query, determines the Tokens and calls the parser [ via `static void Parse( yyParser * , int, Term * , State * )`_ ) each time a new Token is determined, along with the information of that Token.

The lexer uses the enum mode to keep track of the present state and the information of the past Token(s).::

    enum {
	DEFAULT, IN_QUOTES, IN_PREFIXED_QUOTES, IN_PHRASED_TERM, IN_GROUP,
	IN_GROUP2, EXPLICIT_SYNONYM
    } mode = DEFAULT;  

The default value of mode is DEFAULT.

Following is the information regarding each of them :

DEFAULT
--------
This is the default value of mode.

IN_QUOTES
----------
If ' ``"`` ' character detected along with the conditions that are required for Quotes (as mentioned above in `QUOTE`_ ), then the mode is set to this one and parser is called with parameters as::

     Parse(pParser, QUOTE, NULL, &state);


IN_PREFIXED_QUOTES
-------------------
Same as `IN_QUOTES`_, and the Parse is called with same parameters.

The only difference is that it corresponds to a case like 

    subject:"space flight"

where "``subject``" corresponds to a filter.


IN_PHRASED_TERM
----------------
The character is tested for phrase generator (as mentioned above in `PHR_TERM`_ ), and if it is, then the mode is set to this one and the parser is called with the parameters as::

    Parse(pParser, PHR_TERM, term_obj, &state);


IN_GROUP
---------
If the we have a term, and we detect another term such that they are separated only via whitespace (as mentioned above in `group`_), then this mode is set.

IN_GROUP2
-----------
This is same as `IN_GROUP`_ with the difference that this corresponds to the case when we have more than two terms separated via whitespace.


EXPLICIT_SYNONM
-----------------
If ' ``~`` ' character is detected along with the conditions that are required for Synonyms (as described above in `SYNONYM`_), then the mode is set to this one and the parser is called with parameters as::

    Parse(pParser, SYNONYM, NULL, &state);
