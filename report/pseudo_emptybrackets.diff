diff --git a/xapian-core/queryparser/queryparser.lemony b/xapian-core/queryparser/queryparser.lemony
index 8dedb80..0927f93 100644
--- a/xapian-core/queryparser/queryparser.lemony
+++ b/xapian-core/queryparser/queryparser.lemony
@@ -114,6 +114,30 @@ is_positional(Xapian::Query::op op)
     return (op == Xapian::Query::OP_PHRASE || op == Xapian::Query::OP_NEAR);
 }
 
+inline bool
+pseudo_brackets_tell(unsigned ch) {
+    return ch == ')' || ch == '(' || is_wordchar(ch);
+} 
+ 
+inline bool 
+pseudo_brackets_checker(Utf8Iterator it)
+{
+    Utf8Iterator end;
+    
+    //Also check for '(' since there may be the case of nested brackets. If
+    //so, then would be better to just refer the present character as token
+    //BRA rather than iterating further to see what the case is.
+    Utf8Iterator bra_ket_wordchar = find_if(it, end, pseudo_brackets_tell);
+    
+    //If Reached end or reached ')', then don't consider it as the token BRA
+    if (bra_ket_wordchar == end || *bra_ket_wordchar == ')') {
+        return true;
+    }
+
+    //Else the current character can be called the token BRA.
+    return false;
+}
+
 /// A structure identifying a group of filter terms or a value range.
 struct filter_group_id {
     /** The prefix info for boolean filter terms.
@@ -926,6 +950,15 @@ just_had_operator_needing_term:
 		    newprev = *it++;
 		    break;
 		}
+		//Ignore brackets containing only non-word characters inside them
+		if (pseudo_brackets_checker(it)) {
+		    //We have to move the iterator forward since there are
+		    //just characters between the brackets
+		    it = find_if(it, end, pseudo_brackets_tell);
+		    if (it == end) goto done;
+		    newprev = *it++;
+		    break;
+		}
 		if (mode == DEFAULT && (flags & FLAG_BOOLEAN)) {
 		    prefix_stack.push_back(prefix_stack.back());
 		    Parse(pParser, BRA, NULL, &state);
