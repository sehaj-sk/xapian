Lucene uses the lexer as well as parser generated by JavaCC. Java Compiler Compiler (JavaCC)
is a popular parser generator for use with Java applications.  For the parser, JavaCC uses
LL grammar and generates LL(1) parser with the option to make the parser behave like LL(k)
at some points to resolve conflicts.
Thus the parser is a Top-Down Parser.

For the lexer (i.e. the tokenizer), Lucene uses regular expressions for the specifications of
tokens for the lexer. Using the given regular expressions, JavaCC
generates the lexer.

Following are the results given by Lucene with default settings (using Standard Analyser and
other default settings of QueryParser) for the points present in summary.txt




1.a
Lucene treats the opening bracket '(' as the token irrespective of whether it appears after a
whitespace or not.
Hence it is able to get off from the 1.a types of errores.

For example, for the query : laatsteIndex(int n) , (as given in the example in summary.txt),
following tokens are produced :
Token[0] = laatsteIndex
Token[1] = (
Token[2] = int
Token[3] = n
Token[4] = )

And the final query object that lucene Query parser generates for this query is : laatsteindex
(int n) , i.e. the character '(' after the term laatsteIndex (without whitespace) isnot ignored
and is detected as a token.



1.b
Lucene also generates an error for such queries with emoticons.


1.c
Lucene also generates an error for such queries.


1.d
For Queries like "(./) chmod.sh", (as given in the example in summary.txt), Lucene lexer doesn't
ignore the characters inside the brackets, i.e. for this query the tokens produced are as follow -
Token[0] = (
Token[1] = ./
Token[2] = )
Token[3] = chmod.sh

But the final query object that lucene QueryParser generates for this query is : chmod.sh ,
i.e. here the "(./)" part doesn't come.


1.e
In this case Lucene treats "libgd." as a TERM and then ( as opening bracket. Thus no parse error.


2.a
Like mentioned in 1.d, here also the characters between quotes are not ignored by Lucene.

For example, for the query : "'" +asp, (as given in the example in summary.txt), following
tokens are produced :
Token[0] = "'"
Token[1] = +
Token[2] = asp

And the final query object formed is : +asp , i.e. here also like in 1.d, the part "'"
doesn't come.

Similarly for query : raar "~" bestand (as given in the example in summary.txt), following
tokens are produced :
Token[0] = raar
Token[1] = "~"
Token[2] = bestand

And the final query object returned is : raar bestand . Here too, like above, the part "~"
is ignored.



2.b
Lucene also gives Lexical error in this case.



3.
Like above in 1.d and 2.a, here also lucene doesn't ignore the characters after '+' or '-'
(Lucene Query syntax also refers to these charactesrs as equivalent to xapan's LOVE and HATE).

For example, for the query : dvd +/- , (as given in the example in summary.txt), following
tokens are produced :
Token[0] = dvd
Token[1] = +
Token[2] = /-

And the final query object that lucene Query parser generates for this query is : dvd , i.e. here
also the part "+/-" is ignored.


4.
Lucene doesn't have such a syntax.


5.
Lucene supports both LOVE as well as HATE terms inside brackets. Thus both the queries
"(+xapian)" and "(-xapian)" gets parsed.
It seems it deals with the case of single HATE term differently.
Thus all the examples for this part given in summary.txt are parsed correctly without any errors
by lucene.
